---
- name: Playbook automatically run by ansible-pull 
  hosts: localhost
  vars:
    - vmname: pulltest-change
  connection: ansible.builtin.local
  gather_facts: false
  strategy: host_pinned # free  #allows each cluster to start next task before all clusters have finished current task
  # environment: # assumes these are already set up for each site in ansible-pull.yml setup playbook 
  #   SC_HOST: "https://10.100.20.25"
  #   SC_USERNAME: "admin"
  #   SC_PASSWORD: "admin"  

  tasks:
  - name: Download ISO image from http://tinycorelinux.net/13.x/x86/release/TinyCore-current.iso and save it into /tmp/TinyCore-vm-integration.iso
    get_url: 
      url: http://tinycorelinux.net/13.x/x86/release/TinyCore-current.iso 
      dest: /tmp/TinyCore-vm-integration.iso
      force: false
    become: true

  - name: Upload ISO image TinyCore-vm-integration.iso to HyperCore API
    scale_computing.hypercore.iso:
      name: "TinyCore-current.iso"
      source: "/tmp/TinyCore-vm-integration.iso"
      state: present
    register: result
    become: true

  # - name: get all vms 
  #   scale_computing.hypercore.vm_info:
  #   register: vm_info

  - name: Create and start the VM with disks, nics and boot devices set. Attach ISO onto the VM. Add cloud init data
    scale_computing.hypercore.vm:
      vm_name: "{{ vmname }}"
      description: Demo VM created via ansible-pull
      state: present
      tags:
        - ansible-pull
        - "{{ vmname }}"
      memory: "{{ '1GB' | human_to_bytes }}"
      vcpu: 2
      power_state: start
      disks:
        - type: ide_cdrom
          disk_slot: 0
          iso_name: "TinyCore-current.iso"
        - type: virtio_disk
          disk_slot: 0
          size: "{{ '10 GB' | human_to_bytes }}"
      nics:
        - vlan: 0
          type: virtio
      boot_devices:
        - type: ide_cdrom
          disk_slot: 0
        - type: virtio_disk
          disk_slot: 0
      cloud_init:
        user_data: |
          #cloud-config
          password: "password"
          chpasswd: { expire: False }
          ssh_pwauth: True
          apt: {sources: {docker.list: {source: 'deb [arch=amd64] https://download.docker.com/linux/ubuntu $RELEASE stable', keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88}}}
          packages: [qemu-guest-agent, docker-ce, docker-ce-cli, docker-compose, ansible, git, unzip]
          bootcmd:
            - [ sh, -c, 'sudo echo GRUB_CMDLINE_LINUX="nomodeset" >> /etc/default/grub' ]
            - [ sh, -c, 'sudo echo GRUB_GFXPAYLOAD_LINUX="1024x768" >> /etc/default/grub' ]
            - [ sh, -c, 'sudo echo GRUB_DISABLE_LINUX_UUID=true >> /etc/default/grub' ]
            - [ sh, -c, 'sudo update-grub' ]
          runcmd:
            - [ systemctl, restart, --no-block, qemu-guest-agent ]
          write_files:
          # configure docker daemon to be accessible remotely via TCP on socket 2375
          - content: |
              [Service]
              ExecStart=
              ExecStart=/usr/bin/dockerd -H unix:// -H tcp://0.0.0.0:2375
            path: /etc/systemd/system/docker.service.d/options.conf
        meta_data: |
          dsmode: local
          local-hostname: "{{ vmname }}"
      machine_type: BIOS
    register: vm_created

  - name: Start pgAdmin4 container
    community.docker.docker_container:
      name: pgadmin4_demo
      image: dpage/pgadmin4
      state: started
      ports:
        - "80:80"
      env:
        PGADMIN_DEFAULT_EMAIL: "admin@example.com"
        PGADMIN_DEFAULT_PASSWORD: "admin"
    become: yes

  - name: Deploy the application using Docker Compose
    community.docker.docker_compose:
      project_name: wordpress
      definition:
        version: '3.3'

        services:
          db:
            image: mysql:5.7
            volumes:
              - db_data:/var/lib/mysql
            environment:
              MYSQL_ROOT_PASSWORD: somewordpress
              MYSQL_DATABASE: wordpress
              MYSQL_USER: wordpress
              MYSQL_PASSWORD: wordpress
          wordpress:
            depends_on:
              - db
            image: wordpress:latest
            ports:
              - "8000:80"
            environment:
              WORDPRESS_DB_HOST: db:3306
              WORDPRESS_DB_USER: wordpress
              WORDPRESS_DB_PASSWORD: wordpress
              WORDPRESS_DB_NAME: wordpress

        volumes:
          db_data: {}
      state: present
    become: yes