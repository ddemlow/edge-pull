---
- name: Playbook automatically run by ansible-pull 
# currently downloads iso from internet, uploads it to each cluster media, creates VM that boots from iso
# inside "runner" vm deploys simple docker container plus a docker compose configuration
# other things this could do might include downloading virtual disks locally and then uploading them to cluster, could load SAMBA container for file share, etc.
  hosts: localhost
  vars:
    vmname: pull-tinycore
    image_path: /tmp
    image_url:
      - "https://github.com/ddemlow/RestAPIExamples/raw/master/ubuntu20_04-cloud-init/ubuntu20cloudimage.qcow2"
      - "https://github.com/ddemlow/RestAPIExamples/raw/master/RHEL9/RHEL9-disk.qcow2"
    image_filename: "{{ image_url[0] | split('/') | last }}"  # only works for first in list
  environment:  # if set here - hypercore modules will automatically use this for each remote cluster - avoiding need to specify cluster_instance for each test
    SC_TIMEOUT: 2000000

  connection: ansible.builtin.local
  gather_facts: false

  tasks:
  - name: Download ISO image from http://tinycorelinux.net/13.x/x86/release/TinyCore-current.iso and save it into /tmp/TinyCore-vm-integration.iso
    ansible.builtin.get_url:
      url: http://tinycorelinux.net/13.x/x86/release/TinyCore-current.iso
      dest: /tmp/TinyCore-vm-integration.iso
      force: false
    become: true
#    when: "not (ansible.builtin.stat('/tmp/TinyCore-vm-integration.iso') is defined and ansible.builtin.stat('/tmp/TinyCore-vm-integration.iso').stat.exists)"

  # - name: check connection to scale_computing.hypercore.cluster_info
  #   scale_computing.hypercore.cluster_info:


  - name: Upload ISO image TinyCore-vm-integration.iso to HyperCore API
    scale_computing.hypercore.iso:
      name: "TinyCore-current.iso"
      source: "/tmp/TinyCore-vm-integration.iso"
      state: present
    register: result


  # - name: Download Virtual Disks from URL list
  #   ansible.builtin.get_url: #TODO: what if file doesn't download completely?
  #     url: "{{ item }}"
  #     dest: "{{image_path}}"  #{{ item | basename }}"
  #     timeout: 10000
  #     validate_certs: false
  #   register: download
  #   loop: "{{ image_url }}"

  - name: Download Virtual Disks from URL list
    ansible.builtin.get_url:
      url: "{{ item }}"
      dest: "{{ image_path }}/{{ item | basename }}"
      timeout: 10000
      validate_certs: false
    register: download
    loop: "{{ image_url }}"
#    when: "not (ansible.builtin.stat(image_path + '/' + (item | basename)).stat.exists | default(false))"
# TODO skip if file is present - assume it's good


  - name: Delete existing uploading-"{{ item | basename }}" virtual disk # this is just to clean up previous aborts
    scale_computing.hypercore.virtual_disk:
      name: "uploading-{{ item | basename }}"
      state: absent
    register: deleted
    loop: "{{ image_url }}"      

  - name: Upload Virtual Disk {{ item | basename }}" to HyperCore "{{ inventory_hostname }}"
    scale_computing.hypercore.virtual_disk:
      name: "{{ item | basename }}"
      source: "{{image_path}}/{{ item | basename }}"
      state: present
    register: uploadResult
    loop: "{{ image_url }}" 
    ignore_errors: true

  - name: Create and start the VM with disks, nics and boot devices set. Attach ISO onto the VM. Add cloud init data
    scale_computing.hypercore.vm:
      vm_name: "{{ vmname }}"
      description: VM created via ansible-pull running on "{{ inventory_hostname }}" #- "{{ ansible_date_time.iso8601 }}" 
      state: present
      tags:
        - ansible-pull
        - "{{ vmname }}"
      memory: "{{ '1GB' | human_to_bytes }}"
      vcpu: 2
      power_state: start
      force_reboot: true
      disks:
        - type: ide_cdrom
          disk_slot: 0
          iso_name: "TinyCore-current.iso"
        - type: virtio_disk
          disk_slot: 0
          size: "{{ '10 GB' | human_to_bytes }}"
      nics:
        - vlan: 0
          type: virtio
      boot_devices:
        - type: ide_cdrom
          disk_slot: 0
        - type: virtio_disk
          disk_slot: 0
      cloud_init:
        user_data: |
          #cloud-config
          password: "password"
          chpasswd: { expire: False }
          ssh_pwauth: True
          apt: {sources: {docker.list: {source: 'deb [arch=amd64] https://download.docker.com/linux/ubuntu $RELEASE stable', keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88}}}
          packages: [qemu-guest-agent, docker-ce, docker-ce-cli, docker-compose, ansible, git, unzip]
          bootcmd:
            - [ sh, -c, 'sudo echo GRUB_CMDLINE_LINUX="nomodeset" >> /etc/default/grub' ]
            - [ sh, -c, 'sudo echo GRUB_GFXPAYLOAD_LINUX="1024x768" >> /etc/default/grub' ]
            - [ sh, -c, 'sudo echo GRUB_DISABLE_LINUX_UUID=true >> /etc/default/grub' ]
            - [ sh, -c, 'sudo update-grub' ]
          runcmd:
            - [ systemctl, restart, --no-block, qemu-guest-agent ]
          write_files:
          # configure docker daemon to be accessible remotely via TCP on socket 2375
          - content: |
              [Service]
              ExecStart=
              ExecStart=/usr/bin/dockerd -H unix:// -H tcp://0.0.0.0:2375
            path: /etc/systemd/system/docker.service.d/options.conf
        meta_data: |
          dsmode: local
          local-hostname: "{{ vmname }}"
      machine_type: BIOS
    register: vm_created

  - name: Start pgAdmin4 container
    community.docker.docker_container:
      name: pgadmin4_demo
      image: dpage/pgadmin4
      state: started
      ports:
        - "80:80"
      env:
        PGADMIN_DEFAULT_EMAIL: "admin@example.com"
        PGADMIN_DEFAULT_PASSWORD: "admin"
    become: yes

  - name: Deploy the application using Docker Compose
    community.docker.docker_compose:
      project_name: wordpress
      definition:
        version: '3.3'

        services:
          db:
            image: mysql:5.7
            volumes:
              - db_data:/var/lib/mysql
            environment:
              MYSQL_ROOT_PASSWORD: somewordpress
              MYSQL_DATABASE: wordpress
              MYSQL_USER: wordpress
              MYSQL_PASSWORD: wordpress
          wordpress:
            depends_on:
              - db
            image: wordpress:latest
            ports:
              - "8000:80"
            environment:
              WORDPRESS_DB_HOST: db:3306
              WORDPRESS_DB_USER: wordpress
              WORDPRESS_DB_PASSWORD: wordpress
              WORDPRESS_DB_NAME: wordpress

        volumes:
          db_data: {}
      state: present
    become: yes